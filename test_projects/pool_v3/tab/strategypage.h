#ifndef STRATEGYPAGE_H
#define STRATEGYPAGE_H


#include "basetabpage_v3.h"

class QComboBox;
class QWidget;
class DefiStrategyData;
class QLineEdit;
class QFrame;
class QToolButton;
struct StrategyLineData;


// страница для управления линией игры различных стратегий.
// кнопками управления можно стартовать новую линию / остановить линию / закрыть текущую позу / перейти к следующему шагу.
// можно открыть только одную линию по указанному пулу для заданной стратегии.
// закрыть линию можно только если она открыта в текущий момент, но при этом поза на текущем шаге закрыта, т.е. состояние - между шагами.
// перед стартом любой линии настраиваются параметры (соответствующей стратегии) и более они не меняются, пока линия не будет закрыта.
// после открытия линии далее идет управление шагами, для перехода к следующему шагу, закрываем текущую позу, затем открываем новую (т.е. 2 итерации)
// расчеты убытков/прибыли считаются в приоритетном токене.
// цены и объемы ликвидности указываются в приоритетном токене.
//
// 1. dstFollowPrice
// поза переставляется следуя за ценой, ликвидность устанавливается только на 1-м шаге,
// далее при изменении диапазона вся ликвидность и накопленные реварды перераспределяются согласно новому диапазону и текущей цене.
// новая ликвидность не добавляется, т.е. весь риск это ставка на 1-м шаге при открытии линии.
// размер диапазона т.е. дельта p2-p1 фиксирована (именно дельта), абсолютное значение, в нормальных единицах цены.
// исходя из текущей цены, дельте p2-p1 и доли приоритетного токена(%), программа будет сама рассчитывать значения p1, p2,
// такие чтобы максимально близко выполнялись эти условия для текущего пула.
// поля настроек:
//   - сумма приоритетного токена (вносимая ликвиднось)
//   - размер диапазона цены приоритеного токена в единицах 2-го
//   - доля приоритетного токена(%) от  общей ликвидности позы в приритетном токене при текущей цене
//   - индекс токена из пары пула, который будет использоваться для внесения ликвидности на 1-м шаге, т.е. при старте линии.
// алгоритм выполнения очередного шага:
//  1. обновить текущие балансы кошелька, запомнить значения балансов пары токенов из пула.
//  2. запросить состояние пула для определения текущей цены (нормальной)
//  3. на 1-м шаге считываются настройки линии со страницы, на др. данные берутся из записи структуры.
//  4. собирается инфа о текущих объемах обоих активов всей результирующей ликвидности позы (включая реварды) на данном шаге.
//  5. согласно настройкам вычисляется доля одного из токенов которую нужно свапнуть на другой чтобы выполнилось условие 3-й настройки.
//  6. исходя из балансов кошелька проверяется хватает ли токенов  для свопа / открытия следующего шага.
//       если нет, то состояние линии не меняется, сценарий прерывается.
//  7. производится рельный своп этой доли в этом же пуле, с которым работаем, получаем TX_HASH
//  8. проверяется статус выполненного свопа.
//       если не ОК, то состояние линии не меняется, все отстается как было и сценарий прерывается.
//  9. вычисляем p1 / p2 для открытия позы так что бы выполнились все условия настроек (диапазон и доли токенов)
//  10. открываем новую позицию, получаем TX_HASH, запоминаем тиковый диапазон.
//  11. проверяется статус выполненной операции.
//       если не ОК, то состояние линии не меняется, все отстается как было и сценарий прерывается.
//  12. запрашивается текущий список поз, и находится поза где адреса токенов/fee сопадают с пулом ,
//      а также ликвидность > 0 и совпадает тиковый диапазон. запоминаем PID.
//  13. обновить текущие балансы кошелька, убедиться что пара токенов убавилась на нужные величины.
//-----------------------------------------------------------------
// алгоритм закрытия текущего шага:
//  1. обновить текущие балансы кошелька, запомнить значения балансов пары токенов из пула.
//  2. обновить состояние позы
//  3. запоминить все значения: текущю цену в пуле (нормальную) / объемы / реварды и т.д.
//  4. закрыть открытую позу текущего шага.
//  5. проверить статус выполненной операции.
//       если не ОК, то запись шага не меняется, все отстается как было и сценарий прерывается.
//  6. обновить текущие балансы кошелька, проверить значения балансов пары токенов из пула.
//        запоминаем сколько всего вывели из позы по каждому токену из пары.
//  7. провести расчет текущего состояния шага и линии на предмет размера ликвидности а также прироста/убытка.
//      обновляется запись шага и соответствующая строка в таблице.



//DefiStrategyPage
class DefiStrategyPage : public BaseTabPage_V3
{
    Q_OBJECT
public:
    DefiStrategyPage(QWidget*);
    virtual ~DefiStrategyPage() {}

    //выполняется когда пользователь в тулбаре нажимает кнопку "Update"
    void sendUpdateDataRequest() {}

    virtual void setChain(int);

protected:
    QComboBox *m_strategyCombo;
    QComboBox *m_poolCombo;
    QLineEdit *m_startTimeEdit;
    QLineEdit *m_lineResultEdit;
    QMap<QString, QWidget*> m_controls;
    DefiStrategyData *m_dataObj;


    void initPageBoxes();
    void initDataObj();
    void initControlButtons(QFrame*);
    int curStrategy() const;
    QString curPool() const;
    bool curStrategyStable() const;
    void updateControlButtonsState(int line_index = -1);
    void updateStepsTable(int line_index = -1);
    void controlButtonsDisable();
    void restoreStartParamsByLine(const StrategyLineData*); // восстановить на форме значения настроек линии при переключении пулов (если линия открыта)
    void resetStartParamsControls(); // сбросить на форме настройки линии

public slots:
    void slotNodejsReply(const QJsonObject&) {} //получен успешный ответ от скрипта nodejs


private:
    QToolButton* startLineBtn() const;
    QToolButton* stopLineBtn() const;
    QToolButton* closeStepBtn() const;
    QToolButton* nextStepBtn() const;

    float liqSize() const; // полный объем вносимой ликвидности в позу (в приоритетном токене)
    float rangeWidth() const; // ширина ценового диапазона
    quint16 priorTokenPart() const; // доля приоритетного токена от общей ликвидности, %
    quint8 fisrtStepTokenIndex() const; // индекс токена из пары пула, который будет использоваться для внесения ликвидности на 1-м шаге



protected slots:    
    void slotUpdateComboPools();
    void slotPoolChanged();

    void slotStartLine();
    void slotStopLine();
    void slotCloseStep();
    void slotNextStep();



};





#endif // STRATEGYPAGE_H







